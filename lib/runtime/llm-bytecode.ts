/**
 * LLMBytecode — Structured Instruction Format for LLMos
 *
 * The Runtime LLM (Qwen3-VL-8B) does not generate Python or C.
 * It generates structured, deterministic execution instructions
 * that the microcontroller interprets directly.
 *
 * This module defines the formal LLMBytecode types that represent
 * the instruction set used between the Runtime LLM and firmware.
 *
 * Key properties:
 * - Instruction semantics: motor commands, sensor reads, LED control, timing
 * - Variable updates: state mutation within the cycle
 * - State transitions: mode changes, goal updates
 * - Closed-loop structure: every frame assumes the loop continues
 * - External input injection: sensor readings enter at defined points
 * - Deterministic execution: guaranteed on the MCU side
 * - Safety validation: before any actuation
 *
 * The balance between hardcoded tool logic and LLM-generated bytecode
 * is a function of model capability. Small models (4B) use a minimal
 * instruction set to orchestrate pre-built tools. Larger models (8B+)
 * use a richer instruction space to express novel behaviors.
 */

// =============================================================================
// Instruction Types — The LLMBytecode Instruction Set
// =============================================================================

/**
 * Motor command instruction — controls wheel actuators
 */
export interface MotorInstruction {
  type: 'motor';
  target: 'left_wheel' | 'right_wheel' | 'both';
  action: 'forward' | 'backward' | 'stop';
  /** Speed value 0-255, validated by firmware safety layer */
  speed?: number;
  /** Duration in milliseconds, 0 = until next instruction */
  duration_ms?: number;
}

/**
 * Sensor read instruction — requests sensor data injection
 */
export interface SensorInstruction {
  type: 'sensor';
  target: 'camera' | 'distance' | 'imu' | 'battery' | 'all';
  /** Whether to block until reading is available */
  blocking?: boolean;
}

/**
 * LED control instruction — visual feedback
 */
export interface LEDInstruction {
  type: 'led';
  r: number;
  g: number;
  b: number;
  /** Duration in ms, 0 = permanent until changed */
  duration_ms?: number;
}

/**
 * Timing instruction — delays and synchronization
 */
export interface TimingInstruction {
  type: 'timing';
  action: 'wait' | 'sync';
  /** Wait duration in milliseconds */
  duration_ms: number;
}

/**
 * State transition instruction — mode changes and goal updates
 */
export interface StateTransitionInstruction {
  type: 'state_transition';
  /** New execution mode */
  mode?: ExecutionMode;
  /** Updated goal string */
  goal?: string;
  /** Variable updates within this cycle */
  variables?: Record<string, string | number | boolean>;
}

/**
 * Composite instruction — sequence of atomic instructions
 */
export interface CompositeInstruction {
  type: 'composite';
  /** Ordered list of instructions to execute atomically */
  instructions: BytecodeInstruction[];
  /** If true, all instructions must succeed or all are rolled back */
  atomic?: boolean;
}

/**
 * Union type for all bytecode instructions
 */
export type BytecodeInstruction =
  | MotorInstruction
  | SensorInstruction
  | LEDInstruction
  | TimingInstruction
  | StateTransitionInstruction
  | CompositeInstruction;

// =============================================================================
// Execution Modes
// =============================================================================

/**
 * Execution modes that the agent can be in.
 * Corresponds to the agent's behavioral state machine.
 */
export type ExecutionMode =
  | 'idle'
  | 'exploring'
  | 'navigating'
  | 'avoiding_obstacle'
  | 'wall_following'
  | 'recovery'
  | 'emergency_stop'
  | 'charging'
  | 'custom';

// =============================================================================
// Output Frame — What the Runtime LLM emits each cycle
// =============================================================================

/**
 * The output frame emitted by the Runtime LLM after inference.
 * Contains the next instructions, state predictions, and world model updates.
 */
export interface OutputFrame {
  /** Ordered list of instructions to execute this cycle */
  instructions: BytecodeInstruction[];
  /** Updated state predictions (the agent's beliefs about what will happen) */
  state_predictions: StatePrediction[];
  /** World model updates from this cycle's observations */
  world_model_update?: WorldModelUpdate;
  /** Current execution mode after this frame */
  mode: ExecutionMode;
  /** Confidence in this frame's decisions (0-1) */
  confidence: number;
  /** Optional reasoning trace for debugging */
  reasoning?: string;
}

/**
 * A prediction about future state after executing instructions
 */
export interface StatePrediction {
  /** What variable or state this predicts */
  target: string;
  /** Predicted value */
  predicted_value: string | number | boolean;
  /** Confidence in this prediction (0-1) */
  confidence: number;
}

/**
 * Update to the agent's internal world model
 */
export interface WorldModelUpdate {
  /** Grid cell updates: key is "x,y" coordinate string */
  grid_updates?: Record<string, CellState>;
  /** Updated position estimate */
  position?: { x: number; y: number; heading: number };
  /** Objects detected or updated */
  objects?: DetectedObject[];
}

export type CellState = 'clear' | 'obstacle' | 'unknown' | 'visited';

export interface DetectedObject {
  label: string;
  position: { x: number; y: number };
  confidence: number;
}

// =============================================================================
// Safety Validation
// =============================================================================

/**
 * Safety validation result from the firmware layer.
 * Every output frame is validated before execution.
 */
export interface SafetyValidationResult {
  /** Whether the frame passed safety validation */
  passed: boolean;
  /** Instructions that were modified or blocked */
  blocked_instructions: number[];
  /** Reason for any modifications */
  reasons: string[];
  /** The validated (possibly modified) output frame */
  validated_frame: OutputFrame;
}

/**
 * Safety constraints enforced by the firmware runtime
 */
export interface SafetyConstraints {
  /** Maximum motor speed allowed (0-255) */
  max_motor_speed: number;
  /** Minimum distance before emergency stop (cm) */
  emergency_stop_distance_cm: number;
  /** Maximum continuous motor runtime before forced cooldown (ms) */
  max_continuous_motor_ms: number;
  /** Whether to enforce voltage limits */
  enforce_voltage_limits: boolean;
}

export const DEFAULT_SAFETY_CONSTRAINTS: SafetyConstraints = {
  max_motor_speed: 200,
  emergency_stop_distance_cm: 10,
  max_continuous_motor_ms: 30000,
  enforce_voltage_limits: true,
};

// =============================================================================
// Bytecode Parsing & Validation
// =============================================================================

/**
 * Parse an LLM output string into a structured OutputFrame.
 * The Runtime LLM generates JSON that conforms to the OutputFrame schema.
 */
export function parseOutputFrame(raw: string): OutputFrame | null {
  try {
    const jsonMatch = raw.match(/\{[\s\S]*\}/);
    if (!jsonMatch) return null;

    const parsed = JSON.parse(jsonMatch[0]);

    // Validate required fields
    if (!parsed.instructions || !Array.isArray(parsed.instructions)) {
      return null;
    }

    if (!parsed.mode || typeof parsed.mode !== 'string') {
      parsed.mode = 'idle';
    }

    if (typeof parsed.confidence !== 'number') {
      parsed.confidence = 0.5;
    }

    if (!parsed.state_predictions) {
      parsed.state_predictions = [];
    }

    return parsed as OutputFrame;
  } catch {
    return null;
  }
}

/**
 * Validate a bytecode instruction for safety and well-formedness
 */
export function validateInstruction(instruction: BytecodeInstruction): { valid: boolean; error?: string } {
  switch (instruction.type) {
    case 'motor':
      if (!['left_wheel', 'right_wheel', 'both'].includes(instruction.target)) {
        return { valid: false, error: `Invalid motor target: ${instruction.target}` };
      }
      if (!['forward', 'backward', 'stop'].includes(instruction.action)) {
        return { valid: false, error: `Invalid motor action: ${instruction.action}` };
      }
      if (instruction.speed !== undefined && (instruction.speed < 0 || instruction.speed > 255)) {
        return { valid: false, error: `Motor speed out of range: ${instruction.speed}` };
      }
      return { valid: true };

    case 'sensor':
      if (!['camera', 'distance', 'imu', 'battery', 'all'].includes(instruction.target)) {
        return { valid: false, error: `Invalid sensor target: ${instruction.target}` };
      }
      return { valid: true };

    case 'led':
      if (instruction.r < 0 || instruction.r > 255 ||
          instruction.g < 0 || instruction.g > 255 ||
          instruction.b < 0 || instruction.b > 255) {
        return { valid: false, error: 'LED values must be 0-255' };
      }
      return { valid: true };

    case 'timing':
      if (!['wait', 'sync'].includes(instruction.action)) {
        return { valid: false, error: `Invalid timing action: ${instruction.action}` };
      }
      if (instruction.duration_ms < 0 || instruction.duration_ms > 60000) {
        return { valid: false, error: `Timing duration out of range: ${instruction.duration_ms}` };
      }
      return { valid: true };

    case 'state_transition':
      return { valid: true };

    case 'composite':
      if (!instruction.instructions || instruction.instructions.length === 0) {
        return { valid: false, error: 'Composite instruction must have at least one sub-instruction' };
      }
      for (const sub of instruction.instructions) {
        const subResult = validateInstruction(sub);
        if (!subResult.valid) return subResult;
      }
      return { valid: true };

    default:
      return { valid: false, error: `Unknown instruction type: ${(instruction as any).type}` };
  }
}

/**
 * Validate an entire output frame against safety constraints
 */
export function validateOutputFrame(
  frame: OutputFrame,
  constraints: SafetyConstraints = DEFAULT_SAFETY_CONSTRAINTS
): SafetyValidationResult {
  const blockedInstructions: number[] = [];
  const reasons: string[] = [];
  const validatedInstructions: BytecodeInstruction[] = [];

  for (let i = 0; i < frame.instructions.length; i++) {
    const instruction = frame.instructions[i];
    const validation = validateInstruction(instruction);

    if (!validation.valid) {
      blockedInstructions.push(i);
      reasons.push(validation.error!);
      continue;
    }

    // Apply safety constraints to motor instructions
    if (instruction.type === 'motor' && instruction.speed !== undefined) {
      if (instruction.speed > constraints.max_motor_speed) {
        const clamped: MotorInstruction = {
          ...instruction,
          speed: constraints.max_motor_speed,
        };
        validatedInstructions.push(clamped);
        reasons.push(`Motor speed clamped from ${instruction.speed} to ${constraints.max_motor_speed}`);
        continue;
      }
    }

    validatedInstructions.push(instruction);
  }

  const validatedFrame: OutputFrame = {
    ...frame,
    instructions: validatedInstructions,
  };

  return {
    passed: blockedInstructions.length === 0 && reasons.length === 0,
    blocked_instructions: blockedInstructions,
    reasons,
    validated_frame: validatedFrame,
  };
}
